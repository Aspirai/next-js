### 常见名词解释

## 1.什么是Docker容器？

Docker是一种轻量级的虚拟化技术，同时是一个开源的应用容器运行环境搭建平台，可以让开发者以便捷方式打包应用到一个可移植的容器中，然后安装至任何运行Linux或Windows等系统的服务器上。相较于传统虚拟机，Docker容器提供轻量化的虚拟化方式、安装便捷、启停速度快。

## 2.为什么需要Docker容器？

虚拟机（Virtual  Machine，简称VM）的发展，减轻了企业对硬件资源的依赖，它将一台物理设备虚拟为多个逻辑设备，每个逻辑设备可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高设备的工作效率。然而，传统VM需要安装操作系统才能执行应用程序，占用系统资源过多。多数情况下，用户只需要运行简单的应用程序，采用VM技术操作繁琐且造成资源浪费。倘若需要迁移应用服务程序，则需迁移整个VM，因此企业迫切需要轻量级的虚拟化技术。

容器，就是一种轻量级的虚拟化技术，目的和虚拟机一样，都是为了创造“隔离环境”。但是它不像VM采用操作系统级的资源隔离，容器采用的是进程级的系统隔离。Docker作为创建容器的主流工具，近年来迅速发展，它的优势在于可以让开发者将企业需要的各种应用及应用依赖文件封装在Docker[镜像](https://info.support.huawei.com/info-finder/encyclopedia/zh/镜像.html)文件中，然后在任何物理设备（Linux设备或Window设备等）上安装运行实现虚拟化，让应用程序彻底脱离底层设备，可以在物理机之间灵活迁移部署，使运维工程师摆脱了繁琐的环境部署，极大的提高了工作效率，同时减少了部署过程中的潜在风险。

Docker容器具有以下三大特点：

- 轻量化：一台主机上运行的多个Docker容器可以共享主机操作系统内核；启动迅速，只需占用很少的计算和内存资源。
- 标准开放：Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。
- 安全可靠：Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台主机。


边缘函数（EdgeRoutine，简称ER）是一项基于Serverless架构的服务，它允许开发者编写JavaScript代码并在阿里云全球边缘节点上部署和执行，支持ES6语法和标准的Web Service Worker  API。通过这种技术，用户的请求可以直接在离用户最近的边缘节点上得到响应处理，从而显著减少延迟、提高响应速度，并实现更低时延的计算体验。

![image](https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/9046976171/CAEQShiBgMDvk4ug2BgiIGFkMThiMzk1ZDRhMTRjMGQ4YmE3N2NlNTdiMjUxMDE44020181_20230926172954.921.svg)

## 3.对象存储 COS是什么？

对象存储（Cloud Object Storage，COS）是由腾讯云推出的无目录层次结构、无数据格式限制，可容纳海量数据且支持  HTTP/HTTPS 协议访问的分布式存储服务。腾讯云 COS 的存储桶空间无容量上限，无需分区管理，适用于 CDN  数据分发、数据万象处理或大数据计算与分析的数据湖等多种场景。

## 4.Redis是什么？

Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：

- ```
  - 基于内存运行，性能高效
  - 支持分布式，理论上可以无限扩展
  - key-value存储系统
  - 开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API
  ```

相比于其他数据库类型，Redis具备的特点是：

- ```
  - C/S通讯模型
  - 单进程单线程模型
  - 丰富的数据类型
  - 操作具有原子性
  - 持久化
  - 高并发读写
  - 支持lua脚本
  ```

## 5.归一化图表解释

```
归一化图表是一种数据可视化方法，用于将不同范围的数据缩放到一个统一的范围（通常是0到1）以便于比较和分析。这样可以消除数据规模的影响，使得不同数据集之间的模式和趋势更加明显。

例如，在展示多个不同单位或量级的数据时，通过归一化处理，所有数据都会被转换到相同的比例范围内，这样可以更直观地比较它们的变化趋势。

你可以使用如下的公式对数据进行归一化处理：

x′=x−min⁡(x)max⁡(x)−min⁡(x)x' = \frac{x - \min(x)}{\max(x) - \min(x)}x′=max(x)−min(x)x−min(x)

其中，xxx 是原始数据值，min⁡(x)\min(x)min(x) 和 max⁡(x)\max(x)max(x) 分别是数据集的最小值和最大值，x′x'x′ 是归一化后的值。
```

## 6.读音

```
Gitee----吉tea;
Github----吉特哈布；
```

## 7.大模型指？

大模型（Large Model）通常指的是大规模预训练模型，特别是在自然语言处理（NLP）和生成模型领域。这些模型通过大量的数据进行训练，能够理解和生成自然语言。以下是一些常见的大模型：

    GPT（Generative Pre-trained Transformer）系列：例如GPT-3和GPT-4，这些模型通过大规模的文本数据进行预训练，能生成高质量的文本。
    
    BERT（Bidirectional Encoder Representations from Transformers）：一个双向的Transformer模型，用于各种NLP任务，例如问答、文本分类等。
    
    T5（Text-to-Text Transfer Transformer）：将所有NLP任务都转化为文本到文本的格式进行处理。
    
    Transformer：一种神经网络架构，广泛应用于序列到序列任务，如机器翻译、文本生成等。

大模型的优势在于它们的广泛适用性和强大的生成和理解能力，但也需要大量的计算资源和数据进行训练。

## 8.如何训练（跑）大模型

训练一个大模型需要收集和清洗大量数据，选择和配置合适的模型架构，设置训练环境和优化器，通过多轮迭代优化模型参数，监控和调整参数，最终评估模型性能并进行部署。

```
**训练阶段**：在训练过程中，数据被分批输入模型进行训练，使用大量计算资源进行多轮迭代，优化模型参数。
**推理阶段**：在推理（或推断）过程中，使用训练好的模型对新数据进行预测或生成。这通常涉及将输入数据通过模型进行前向传播，输出预测结果。
```

## 9.堆叠图表

堆叠图表是一种数据可视化图表类型，其中多个数据系列（或类别）的值被堆叠在一起，以显示它们的总和以及各个部分对整体的贡献。这种图表特别适合用于比较不同类别的贡献，同时展示整体趋势。

```
堆叠图表的类型
    堆叠柱状图（Stacked Bar Chart）：垂直方向的堆叠。
    堆叠条形图（Stacked Column Chart）：水平方向的堆叠。
    堆叠面积图（Stacked Area Chart）：数据系列以面积的形式堆叠。
    堆叠折线图（Stacked Line Chart）：数据系列以折线的形式堆叠。
```

## 10.CSSProperties

CSSProperties 是 TypeScript 中用于定义内联样式对象的类型。它是 React 提供的一个类型定义，用于确保在 JSX 中内联样式的属性和值符合标准的 CSS 属性和值。

在 React 中，如果你想在组件的 style 属性中应用内联样式，可以使用一个 JavaScript 对象来定义这些样式。CSSProperties 就是这个对象的类型定义。

## 11.display----CSS

在 CSS 中，`display` 属性定义了一个元素如何显示在页面上，或者说它的布局行为。它决定了元素是作为块级元素、内联元素还是其他类型的布局模式进行渲染。`display` 是控制布局和视觉效果的一个重要属性。

**`display: block;`**

- 元素作为块级元素显示。块级元素会独占一行，宽度默认撑满父容器。
- 示例：`<div>`、`<p>`、`<h1>` 等元素默认就是块级元素。

**`display: inline;`**

- 元素作为内联元素显示。内联元素不会独占一行，宽度由内容决定，多个内联元素可以在同一行中排列。
- 示例：`<span>`、`<a>`、`<strong>` 等元素默认是内联元素。

**`display: inline-block;`**

- 元素同时具备内联元素和块级元素的特性。它像内联元素那样与其他元素在同一行显示，但又可以像块级元素那样设置宽度和高度。
- 示例：适用于需要在一行中排列的自定义按钮或卡片组件。

**`display: flex;`**

- 将元素设置为弹性盒布局容器。其子元素（即弹性项目）可以根据 `flex` 相关属性进行灵活排列，适合构建复杂的布局。
- 示例：常用于构建响应式的导航栏、图片库等布局。

**`display: grid;`**

- 将元素设置为网格布局容器。子元素按行和列排列，可以实现二维布局。
- 示例：适用于创建网格系统、复杂的网页布局。

**`display: none;`**

- 元素不显示，且不占据任何空间。它从视觉上和文档流中完全移除。
- 示例：用于隐藏元素，不让它显示在页面上。

**`display: inline-flex;`**

- 类似于 `display: flex;`，但容器本身作为内联元素显示。其内部元素依然按 `flex` 布局排列。

**`display: inline-grid;`**

- 类似于 `display: grid;`，但容器本身作为内联元素显示。其内部元素依然按 `grid` 布局排列。

## 12.flex相关属性

### 1. **Flex 容器相关属性**

这些属性应用于设置了 `display: flex;` 或 `display: inline-flex;` 的父容器上。

#### 1.1 `flex-direction`

- **定义**: 设置主轴的方向，即 flex 项目的排列方向。

- 值

  :

  - `row`: 水平，从左到右排列（默认）。
  - `row-reverse`: 水平，从右到左排列。
  - `column`: 垂直，从上到下排列。
  - `column-reverse`: 垂直，从下到上排列。

#### 1.2 `flex-wrap`

- **定义**: 控制 flex 项目是否在一行中显示或允许换行。

- 值

  :

  - `nowrap`: 所有项目不换行（默认）。
  - `wrap`: 项目按行排列，超过一行时自动换行。
  - `wrap-reverse`: 项目按行排列，但换行方向反转。

#### 1.3 `flex-flow`

- **定义**: `flex-direction` 和 `flex-wrap` 的简写形式。
- **值**: `flex-direction` 和 `flex-wrap` 的组合值，例如 `row wrap`。

#### 1.4 `justify-content`

- **定义**: 控制 flex 项目沿主轴（水平轴）的对齐方式。

- 值

  :

  - `flex-start`: 向主轴起点对齐（默认）。
  - `flex-end`: 向主轴终点对齐。
  - `center`: 居中对齐。
  - `space-between`: 两端对齐，项目之间的间距平均分布。
  - `space-around`: 每个项目两侧的间距相等。
  - `space-evenly`: 项目之间的间距和项目与容器边缘的间距相等。

#### 1.5 `align-items`

- **定义**: 控制 flex 项目沿交叉轴（垂直轴）的对齐方式。

- 值

  :

  - `flex-start`: 向交叉轴起点对齐。
  - `flex-end`: 向交叉轴终点对齐。
  - `center`: 居中对齐。
  - `baseline`: 按照项目的第一行文字的基线对齐。
  - `stretch`: 如果项目未设置高度或高度为 `auto`，将填满整个容器的高度（默认）。

#### 1.6 `align-content`

- **定义**: 控制多行 flex 项目（有 `flex-wrap` 时）的对齐方式。

- 值

  :

  - `flex-start`: 向交叉轴起点对齐。
  - `flex-end`: 向交叉轴终点对齐。
  - `center`: 居中对齐。
  - `space-between`: 两端对齐，项目之间的间距平均分布。
  - `space-around`: 每个项目两侧的间距相等。
  - `space-evenly`: 项目之间的间距和项目与容器边缘的间距相等。
  - `stretch`: 拉伸项目以填充容器（默认）。

### 2. **Flex 项目相关属性**

这些属性应用于 flex 容器内的子元素（即 flex 项目）上。

#### 2.1 `order`

- **定义**: 设置 flex 项目的排列顺序。默认值为 `0`，值越小，项目排列越靠前。
- **值**: 任何整数，如 `-1`, `0`, `1`。

#### 2.2 `flex-grow`

- **定义**: 定义 flex 项目如何分配剩余的空间。默认值为 `0`，即不放大。
- **值**: 任何非负数。如 `1` 表示项目将吸收所有可用空间的比例为 1。

#### 2.3 `flex-shrink`

- **定义**: 定义 flex 项目如何缩小以适应容器的空间。默认值为 `1`，即项目可以缩小。
- **值**: 任何非负数。如 `0` 表示项目不缩小，`1` 表示项目将根据剩余空间进行缩小。

#### 2.4 `flex-basis`

- **定义**: 设置 flex 项目的初始大小，即分配剩余空间之前的大小。默认值为 `auto`，可以是具体的长度值（如 `20%`, `100px`）。
- **值**: `auto` 或长度值（`px`，`em`，`%` 等）。

#### 2.5 `flex`

- **定义**: `flex-grow`、`flex-shrink` 和 `flex-basis` 的简写形式，常用来定义项目的增长、缩小行为。
- **值**: 例如 `flex: 1;` 是 `flex-grow: 1; flex-shrink: 1; flex-basis: 0%` 的简写。

#### 2.6 `align-self`

- **定义**: 允许单个 flex 项目覆盖其父容器的 `align-items` 设置，控制该项目在交叉轴上的对齐方式。

- 值

  :

  - `auto`: 继承父容器的 `align-items` 属性（默认）。
  - `flex-start`: 向交叉轴起点对齐。
  - `flex-end`: 向交叉轴终点对齐。
  - `center`: 居中对齐。
  - `baseline`: 按照项目的第一行文字的基线对齐。
  - `stretch`: 如果项目未设置高度或高度为 `auto`，将填满整个容器的高度。

## 13.IPv6 和 IPv4区别

```
IPv4：采用点分十进制表示，每个部分的值范围是 0 到 255（例如，192.168.1.1）。
IPv6：采用冒号分隔的十六进制表示，可以省略连续的零组，表示为双冒号（例如，2001:0db8::8a2e:0370:7334 代表 2001:0db8:0000:0000:0000:8a2e:0370:7334）。
```

IPv4 和 IPv6 的主要区别在于地址空间的大小和协议设计的复杂性。IPv6 通过提供更大的地址空间、更好的安全性和优化的网络功能，为现代互联网的发展提供了强大的支持。随着互联网设备的不断增加，IPv6 的普及将成为未来网络的主流。

## 14.WebSocket是什么？

WebSocket 是一种计算机通信协议，属于传输层协议的一个应用，它在客户端和服务器之间提供了一个全双工通信通道。WebSocket 协议在 2011 年被标准化为 RFC 6455，并被现代浏览器广泛支持。

### WebSocket 的特点

1. **全双工通信**：WebSocket 提供了全双工（full-duplex）的通信方式，允许客户端和服务器同时发送和接收数据。这与传统的 HTTP 请求-响应模式不同，WebSocket 更适合需要频繁数据交换的场景，比如实时聊天、在线游戏、股票行情推送等。
2. **低延迟**：一旦 WebSocket 连接建立，客户端和服务器之间的通信不需要反复创建和关闭连接，从而减少了通信延迟。传统的 HTTP 请求每次通信都需要开销较大的握手过程，而 WebSocket 只在连接建立时进行一次握手，之后通信通过持久化连接进行。
3. **节省带宽**：WebSocket 的通信报文头很小，在连接建立后，客户端和服务器之间的每次通信只需要传输很少的额外数据，节省了带宽。
4. **实时性强**：因为 WebSocket 可以随时发送和接收数据，它非常适合实时应用，尤其是在需要实时更新数据的场景下（例如：实时消息通知、在线游戏等）。
